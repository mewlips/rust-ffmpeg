#![crate_id = "avfilter#3"]
#![license = "MIT"]
#![crate_type = "dylib"]
/* automatically generated by rust-bindgen */
extern crate libc;
extern crate avutil;
use libc::{c_void,c_int,c_uint,c_schar,uint8_t,int64_t,uint64_t,int8_t};

pub type __int128_t = c_void;
pub type __uint128_t = c_void;
pub type __builtin_va_list = [__va_list_tag, ..1u];
pub type AVFilterContext = Struct_AVFilterContext;
pub type AVFilterLink = Struct_AVFilterLink;
pub type AVFilterPad = Struct_AVFilterPad;
pub type Struct_AVFilterFormats = c_void;
pub type AVFilterFormats = Struct_AVFilterFormats;
pub struct Struct_AVFilterBuffer {
    pub data: [*mut uint8_t, ..8u],
    pub extended_data: *mut *mut uint8_t,
    pub linesize: [c_int, ..8u],
    _priv: *mut c_void,
    pub free: extern "C" fn(arg1: *mut Struct_AVFilterBuffer),
    pub format: c_int,
    pub w: c_int,
    pub h: c_int,
    pub refcount: c_uint,
}
pub type AVFilterBuffer = Struct_AVFilterBuffer;
pub struct Struct_AVFilterBufferRefAudioProps {
    pub channel_layout: uint64_t,
    pub nb_samples: c_int,
    pub sample_rate: c_int,
    pub channels: c_int,
}
pub type AVFilterBufferRefAudioProps = Struct_AVFilterBufferRefAudioProps;
pub struct Struct_AVFilterBufferRefVideoProps {
    pub w: c_int,
    pub h: c_int,
    pub sample_aspect_ratio: avutil::AVRational,
    pub interlaced: c_int,
    pub top_field_first: c_int,
    pub pict_type: avutil::Enum_AVPictureType,
    pub key_frame: c_int,
    pub qp_table_linesize: c_int,
    pub qp_table_size: c_int,
    pub qp_table: *mut int8_t,
}
pub type AVFilterBufferRefVideoProps = Struct_AVFilterBufferRefVideoProps;
pub struct Struct_AVFilterBufferRef {
    pub buf: *mut AVFilterBuffer,
    pub data: [*mut uint8_t, ..8u],
    pub extended_data: *mut *mut uint8_t,
    pub linesize: [c_int, ..8u],
    pub video: *mut AVFilterBufferRefVideoProps,
    pub audio: *mut AVFilterBufferRefAudioProps,
    pub pts: int64_t,
    pub pos: int64_t,
    pub format: c_int,
    pub perms: c_int,
    _type: avutil::Enum_AVMediaType,
    pub metadata: *mut avutil::AVDictionary,
}
pub type AVFilterBufferRef = Struct_AVFilterBufferRef;
pub struct Struct_AVFilterPad {
    pub name: *c_schar,
    _type: avutil::Enum_AVMediaType,
    pub min_perms: c_int,
    pub rej_perms: c_int,
    pub start_frame: extern "C" fn
                     (arg1: *mut AVFilterLink, arg2: *mut AVFilterBufferRef)
                     -> c_int,
    pub get_video_buffer: extern "C" fn
                          (arg1: *mut AVFilterLink, arg2: c_int, arg3: c_int,
                           arg4: c_int) -> *mut AVFilterBufferRef,
    pub get_audio_buffer: extern "C" fn
                          (arg1: *mut AVFilterLink, arg2: c_int, arg3: c_int)
                          -> *mut AVFilterBufferRef,
    pub end_frame: extern "C" fn(arg1: *mut AVFilterLink) -> c_int,
    pub draw_slice: extern "C" fn
                    (arg1: *mut AVFilterLink, arg2: c_int, arg3: c_int,
                     arg4: c_int) -> c_int,
    pub filter_frame: extern "C" fn
                      (arg1: *mut AVFilterLink, arg2: *mut AVFilterBufferRef)
                      -> c_int,
    pub poll_frame: extern "C" fn(arg1: *mut AVFilterLink) -> c_int,
    pub request_frame: extern "C" fn(arg1: *mut AVFilterLink) -> c_int,
    pub config_props: extern "C" fn(arg1: *mut AVFilterLink) -> c_int,
    pub needs_fifo: c_int,
}
pub struct Struct_AVFilter {
    pub name: *c_schar,
    pub description: *c_schar,
    pub inputs: *AVFilterPad,
    pub outputs: *AVFilterPad,
    pub init: extern "C" fn(arg1: *mut AVFilterContext, arg2: *c_schar) -> c_int,
    pub uninit: extern "C" fn(arg1: *mut AVFilterContext),
    pub query_formats: extern "C" fn(arg1: *mut AVFilterContext) -> c_int,
    pub priv_size: c_int,
    pub process_command: extern "C" fn
                         (arg1: *mut AVFilterContext, arg2: *c_schar,
                          arg3: *c_schar, arg4: *mut c_schar, arg5: c_int,
                          arg6: c_int) -> c_int,
    pub init_opaque: extern "C" fn
                     (arg1: *mut AVFilterContext, arg2: *c_schar,
                      arg3: *mut c_void) -> c_int,
    pub priv_class: *avutil::AVClass,
}
pub type AVFilter = Struct_AVFilter;
pub struct Struct_AVFilterContext {
    pub av_class: *avutil::AVClass,
    pub filter: *mut AVFilter,
    pub name: *mut c_schar,
    pub input_pads: *mut AVFilterPad,
    pub inputs: *mut *mut AVFilterLink,
    pub input_count: c_uint,
    pub nb_inputs: c_uint,
    pub output_pads: *mut AVFilterPad,
    pub outputs: *mut *mut AVFilterLink,
    pub output_count: c_uint,
    pub nb_outputs: c_uint,
    _priv: *mut c_void,
    pub command_queue: *mut Struct_AVFilterCommand,
}
pub type Struct_AVFilterCommand = c_void;
pub struct Struct_AVFilterLink {
    pub src: *mut AVFilterContext,
    pub srcpad: *mut AVFilterPad,
    pub dst: *mut AVFilterContext,
    pub dstpad: *mut AVFilterPad,
    _type: avutil::Enum_AVMediaType,
    pub w: c_int,
    pub h: c_int,
    pub sample_aspect_ratio: avutil::AVRational,
    pub channel_layout: uint64_t,
    pub sample_rate: c_int,
    pub format: c_int,
    pub time_base: avutil::AVRational,
    pub in_formats: *mut AVFilterFormats,
    pub out_formats: *mut AVFilterFormats,
    pub in_samplerates: *mut AVFilterFormats,
    pub out_samplerates: *mut AVFilterFormats,
    pub in_channel_layouts: *mut Struct_AVFilterChannelLayouts,
    pub out_channel_layouts: *mut Struct_AVFilterChannelLayouts,
    pub request_samples: c_int,
    pub init_state: Enum_Unnamed1,
    pub pool: *mut Struct_AVFilterPool,
    pub graph: *mut Struct_AVFilterGraph,
    pub current_pts: int64_t,
    pub age_index: c_int,
    pub frame_rate: avutil::AVRational,
    pub partial_buf: *mut AVFilterBufferRef,
    pub partial_buf_size: c_int,
    pub min_samples: c_int,
    pub max_samples: c_int,
    pub cur_buf_copy: *mut AVFilterBufferRef,
    pub closed: c_int,
    pub channels: c_int,
}
pub type Struct_AVFilterChannelLayouts = c_void;
pub type Enum_Unnamed1 = c_uint;
pub static AVLINK_UNINIT: c_uint = 0;
pub static AVLINK_STARTINIT: c_uint = 1;
pub static AVLINK_INIT: c_uint = 2;
pub type Struct_AVFilterPool = c_void;
pub type Struct_AVFilterGraph = c_void;
pub type __va_list_tag = Struct___va_list_tag;
pub struct Struct___va_list_tag {
    pub gp_offset: c_uint,
    pub fp_offset: c_uint,
    pub overflow_arg_area: *mut c_void,
    pub reg_save_area: *mut c_void,
}
#[link(name = "avfilter")]
extern "C" {
    pub fn avfilter_version() -> c_uint;
    pub fn avfilter_configuration() -> *c_schar;
    pub fn avfilter_license() -> *c_schar;
    pub fn avfilter_get_class() -> *avutil::AVClass;
    pub fn avfilter_copy_buffer_ref_props(dst: *mut AVFilterBufferRef,
                                          src: *mut AVFilterBufferRef);
    pub fn avfilter_ref_buffer(_ref: *mut AVFilterBufferRef, pmask: c_int) ->
     *mut AVFilterBufferRef;
    pub fn avfilter_unref_buffer(_ref: *mut AVFilterBufferRef);
    pub fn avfilter_unref_bufferp(_ref: *mut *mut AVFilterBufferRef);
    pub fn avfilter_ref_get_channels(_ref: *mut AVFilterBufferRef) -> c_int;
    pub fn avfilter_pad_get_name(pads: *mut AVFilterPad, pad_idx: c_int) ->
     *c_schar;
    pub fn avfilter_pad_get_type(pads: *mut AVFilterPad, pad_idx: c_int) ->
     avutil::Enum_AVMediaType;
    pub fn avfilter_link(src: *mut AVFilterContext, srcpad: c_uint,
                         dst: *mut AVFilterContext, dstpad: c_uint) -> c_int;
    pub fn avfilter_link_free(link: *mut *mut AVFilterLink);
    pub fn avfilter_link_get_channels(link: *mut AVFilterLink) -> c_int;
    pub fn avfilter_link_set_closed(link: *mut AVFilterLink, closed: c_int);
    pub fn avfilter_config_links(filter: *mut AVFilterContext) -> c_int;
    pub fn avfilter_get_video_buffer_ref_from_arrays(data:
                                                         [*mut uint8_t, ..4u],
                                                     linesize: [c_int, ..4u],
                                                     perms: c_int, w: c_int,
                                                     h: c_int,
                                                     format:
                                                         avutil::Enum_AVPixelFormat)
     -> *mut AVFilterBufferRef;
    pub fn avfilter_get_audio_buffer_ref_from_arrays(data: *mut *mut uint8_t,
                                                     linesize: c_int,
                                                     perms: c_int,
                                                     nb_samples: c_int,
                                                     sample_fmt:
                                                         avutil::Enum_AVSampleFormat,
                                                     channel_layout: uint64_t)
     -> *mut AVFilterBufferRef;
    pub fn avfilter_get_audio_buffer_ref_from_arrays_channels(data:
                                                                  *mut *mut uint8_t,
                                                              linesize: c_int,
                                                              perms: c_int,
                                                              nb_samples:
                                                                  c_int,
                                                              sample_fmt:
                                                                  avutil::Enum_AVSampleFormat,
                                                              channels: c_int,
                                                              channel_layout:
                                                                  uint64_t) ->
     *mut AVFilterBufferRef;
    pub fn avfilter_process_command(filter: *mut AVFilterContext,
                                    cmd: *c_schar, arg: *c_schar,
                                    res: *mut c_schar, res_len: c_int,
                                    flags: c_int) -> c_int;
    pub fn avfilter_register_all();
    pub fn avfilter_uninit();
    pub fn avfilter_register(filter: *mut AVFilter) -> c_int;
    pub fn avfilter_get_by_name(name: *c_schar) -> *mut AVFilter;
    pub fn av_filter_next(filter: *mut *mut AVFilter) -> *mut *mut AVFilter;
    pub fn avfilter_open(filter_ctx: *mut *mut AVFilterContext,
                         filter: *mut AVFilter, inst_name: *c_schar) -> c_int;
    pub fn avfilter_init_filter(filter: *mut AVFilterContext, args: *c_schar,
                                opaque: *mut c_void) -> c_int;
    pub fn avfilter_free(filter: *mut AVFilterContext);
    pub fn avfilter_insert_filter(link: *mut AVFilterLink,
                                  filt: *mut AVFilterContext,
                                  filt_srcpad_idx: c_uint,
                                  filt_dstpad_idx: c_uint) -> c_int;
}

pub fn version() -> uint{
    unsafe {
        avfilter_version() as uint
    }
}
pub fn license() -> ~str {
    unsafe {
        std::str::raw::from_c_str(avfilter_license())
    }
}
